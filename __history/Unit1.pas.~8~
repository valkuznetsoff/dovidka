unit Unit1;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, cxGraphics, cxControls, cxLookAndFeels,
  cxLookAndFeelPainters, cxCustomData, cxStyles, cxTL, cxMaskEdit,
  cxTLdxBarBuiltInMenu, dxSkinsCore, dxSkinBlack, dxSkinBlue, dxSkinBlueprint,
  dxSkinCaramel, dxSkinCoffee, dxSkinDarkRoom, dxSkinDarkSide,
  dxSkinDevExpressDarkStyle, dxSkinDevExpressStyle, dxSkinFoggy,
  dxSkinGlassOceans, dxSkinHighContrast, dxSkiniMaginary, dxSkinLilian,
  dxSkinLiquidSky, dxSkinLondonLiquidSky, dxSkinMcSkin, dxSkinMetropolis,
  dxSkinMetropolisDark, dxSkinMoneyTwins, dxSkinOffice2007Black,
  dxSkinOffice2007Blue, dxSkinOffice2007Green, dxSkinOffice2007Pink,
  dxSkinOffice2007Silver, dxSkinOffice2010Black, dxSkinOffice2010Blue,
  dxSkinOffice2010Silver, dxSkinOffice2013DarkGray, dxSkinOffice2013LightGray,
  dxSkinOffice2013White, dxSkinOffice2016Colorful, dxSkinOffice2016Dark,
  dxSkinPumpkin, dxSkinSeven, dxSkinSevenClassic, dxSkinSharp, dxSkinSharpPlus,
  dxSkinSilver, dxSkinSpringTime, dxSkinStardust, dxSkinSummer2008,
  dxSkinTheAsphaltWorld, dxSkinsDefaultPainters, dxSkinValentine,
  dxSkinVisualStudio2013Blue, dxSkinVisualStudio2013Dark,
  dxSkinVisualStudio2013Light, dxSkinVS2010, dxSkinWhiteprint,
  dxSkinXmas2008Blue, Data.DB, Data.Win.ADODB, cxInplaceContainer, cxDBTL,
  cxTLData, Vcl.ExtCtrls, DM, Vcl.StdCtrls, Vcl.Buttons, cxCalendar,
  dxSkinsdxBarPainter, Vcl.Menus, dxBar, dxBarExtItems, cxClasses,
  System.Actions, Vcl.ActnList, Vcl.PlatformDefaultStyleActnCtrls, Vcl.ActnMan,
  System.ImageList, Vcl.ImgList, Unit4, cxCheckBox, IniFiles, MenuItemInjector;

type
  TForm1 = class(TForm)
    TreeList: TcxDBTreeList;
    Treeid: TcxDBTreeListColumn;
    Treeguid: TcxDBTreeListColumn;
    Treeguid_parent: TcxDBTreeListColumn;
    Treelevel_name: TcxDBTreeListColumn;
    Treename: TcxDBTreeListColumn;
    Treedatestart: TcxDBTreeListColumn;
    Treedateexpired: TcxDBTreeListColumn;
    Treelevel: TcxDBTreeListColumn;
    Treeupdated: TcxDBTreeListColumn;
    ImageList: TcxImageList;
    StyleRepository: TcxStyleRepository;
    cxStyle1: TcxStyle;
    cxStyle2: TcxStyle;
    cxStyle3: TcxStyle;
    cxStyle4: TcxStyle;
    cxStyle5: TcxStyle;
    cxStyle6: TcxStyle;
    cxStyle7: TcxStyle;
    cxStyle8: TcxStyle;
    cxStyle9: TcxStyle;
    cxStyle10: TcxStyle;
    cxStyle11: TcxStyle;
    cxStyle12: TcxStyle;
    cxStyle13: TcxStyle;
    stlGroupNode: TcxStyle;
    stlFixedBand: TcxStyle;
    TreeListStyleSheetDevExpress: TcxTreeListStyleSheet;
    ActionMan: TActionManager;
    CreateBaseAction: TAction;
    ConnectBaseAction: TAction;
    DeleteBaseAction: TAction;
    AboutAction: TAction;
    EditAction: TAction;
    ReOpenAction: TAction;
    AddAction: TAction;
    AddChildAction: TAction;
    DeleteAction: TAction;
    RestoreAction: TAction;
    ShowDeletedAction: TAction;
    ActualDateAction: TAction;
    BarMan: TdxBarManager;
    BarManBar1: TdxBar;
    ReCreateBtn: TdxBarButton;
    dxBarButton1: TdxBarButton;
    dxBarButton2: TdxBarButton;
    dxBarButton3: TdxBarButton;
    dxBarButton4: TdxBarButton;
    dxBarButton5: TdxBarButton;
    ActualDate: TdxBarDateCombo;
    dxBarButton6: TdxBarButton;
    dxBarButton7: TdxBarButton;
    TreePopup: TPopupMenu;
    AboutAction2: TMenuItem;
    ReOpenPopupItem: TMenuItem;
    AddPopupItem: TMenuItem;
    AddChildPopupItem: TMenuItem;
    DeletePopupItem: TMenuItem;
    RestorePopupItem: TMenuItem;
    EditPopupItem: TMenuItem;
    ShowDeletedPopupItem: TMenuItem;
    MainMenu: TMainMenu;
    MainMenu1: TMenuItem;
    CreateBaseItem: TMenuItem;
    ConnectBaseItem: TMenuItem;
    DeleteBaseItem: TMenuItem;
    AboutMenuItem: TMenuItem;
    EditMenuItem: TMenuItem;
    ReOpenMenuItem: TMenuItem;
    AddMenuItem: TMenuItem;
    AddChildMenuItem: TMenuItem;
    DeleteMenuItem: TMenuItem;
    RestoreMenuItem: TMenuItem;
    ShowDeletedMenuItem: TMenuItem;
    procedure TreeListDragOver(Sender, Source: TObject; X, Y: Integer;
      State: TDragState; var Accept: Boolean);
    procedure TreeListDragDrop(Sender, Source: TObject; X, Y: Integer);
    procedure TreeListMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure AboutActionExecute(Sender: TObject);
    procedure ReOpenActionExecute(Sender: TObject);
    procedure ShowDeletedActionExecute(Sender: TObject);
    procedure ActualDateActionUpdate(Sender: TObject);
    procedure AddActionExecute(Sender: TObject);
    procedure AddChildActionExecute(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure EditActionExecute(Sender: TObject);
    procedure DeleteActionExecute(Sender: TObject);
    procedure RestoreActionExecute(Sender: TObject);
    procedure TreeListCustomDrawDataCell(Sender: TcxCustomTreeList;
      ACanvas: TcxCanvas; AViewInfo: TcxTreeListEditCellViewInfo;
      var ADone: Boolean);
    procedure DeleteBaseActionExecute(Sender: TObject);
    procedure CreateBaseActionExecute(Sender: TObject);
    procedure ConnectBaseActionExecute(Sender: TObject);
  private
    DragNode: TcxTreeListNode;
    PrevActualDate: TDate;
    LevelNames: TStringList;

    procedure CheckDataBase;
    function DataBaseExists(DBName: string): boolean;
    procedure ExecuteScriptFromFile(aFileName: string);
    procedure ExecuteSQL(aSQL: string);
    function OpenSQL(aSQL: string): TADOQuery;

    function CheckActualDate: boolean;
    function CreateMainQuery: string;

    procedure TreeDragTo(DragGUID, DropGUID: TGUID);

    procedure TreeMoveTo(FromGUID, ToGUID, NewGUID: TGUID); overload;
    procedure TreeMoveTo(FromGUID, NewGUID: TGUID); overload;

    procedure TreeDelete(DeleteGUID: TGUID);

    procedure TreeRestore(RestoreGUID: TGUID; RestoreLevel: integer; RestoreName: string); overload;
    procedure TreeRestore(RestoreGUID, RestoreGUID_Parent: TGUID; RestoreLevel: integer; RestoreName: string); overload;

    procedure TreeListReOpen(aTreeList: TcxDBTreeList); overload;
    procedure TreeListReOpen(aTreeList: TcxDBTreeList; Key: string; Value: Integer); overload;
    procedure TreeListReOpen(aTreeList: TcxDBTreeList; Key: string; Value: TGUID); overload;
    { Private declarations }
  public
    { Public declarations }
  end;

const
  trGUID = 1;
  trGUID_Parent = 2;
  trLevel = 3;
  trName = 5;
  trDateStart = 6;
  trDateExpired = 7;
  trUpdated = 8;

var
  Form1: TForm1;

implementation

{$R *.dfm}
function IIF(Condition: boolean; TrueValue, FalseValue: Variant): Variant;
begin
// Функция проверки условия с возвратом значения
  if Condition then Result := TrueValue else Result := FalseValue
end;

function ConnectToIniFile(aIniFileName: string): TIniFile;
begin
// Проверка на наличие файла в текущем каталоге и при необходимости
// смена пути на 2 уровня назад, исключается "Win32\Debug"
  if not FileExists(aIniFileName) then aIniFileName := '..\..\'+aIniFileName;
  Result := TIniFile.Create(aIniFileName);
end;

function CreateMenuItem(Section: string): TMenuItem;
var
  MenuItem: IMenuItem;
  SomeConsumerObj: TConsumer;
  IniFile: TIniFile;
  Items: TStrings;
  S, Title: string;
  MenuItemIntf: string;
  i: integer;
begin
// Динамическое создание менюшек dependency injection,
// прописанных в файле Menus.Ini
  IniFile := ConnectToIniFile('Menus.Ini');
  try
    Items := TStringList.Create;
    try
      Title := IniFile.ReadString(Section, 'Title', 'Menu');
      Result := TMenuItem.Create(nil);
      Result.Caption := Title;

      IniFile.ReadSectionValues(Section, Items);
      for i:=0 to Pred(Items.Count) do
      begin
        MenuItem := TMenuItemInjector.GetMenuItemIntf(Copy(Items[i], Pos('=', Items[i])+1, 255));
        SomeConsumerObj := TConsumer.Create(MenuItem);

        try
          SomeConsumerObj.DoCreateMenuItem(Result);
        finally
          SomeConsumerObj.Free;
        end;
      end;
    finally
      IniFile.Free;
    end;
  finally
    Items.Free;
  end;
end;

procedure TForm1.TreeListReOpen(aTreeList: TcxDBTreeList);
begin
// Переоткрытие датасета по умолчанию
  TreeListReOpen(aTreeList, 'ID', aTreeList.DataController.DataSet.FieldByName('ID').AsInteger);
end;

procedure TForm1.TreeListReOpen(aTreeList: TcxDBTreeList; Key: string; Value: Integer);
begin
// Переоткрытие датасета по коду
  with aTreeList.DataController do
  begin
    DataSet.Close; DataSet.Open;
    aTreeList.FullExpand; aTreeList.SetFocus;
    DataSet.Locate(Key, Value, [loPartialKey]);
  end;
end;

procedure TForm1.TreeListReOpen(aTreeList: TcxDBTreeList; Key: string; Value: TGUID);
begin
// Переоткрытие датасета по уникальному идентификатору
  with aTreeList.DataController do
  begin
    DataSet.Close; DataSet.Open;
    aTreeList.FullExpand; aTreeList.SetFocus;
    DataSet.Locate(Key, GUIDToString(Value), [loPartialKey]);
  end;
end;

procedure TForm1.TreeListCustomDrawDataCell(Sender: TcxCustomTreeList;
  ACanvas: TcxCanvas; AViewInfo: TcxTreeListEditCellViewInfo;
  var ADone: Boolean);
begin
// Выделение объектов, имеющих потомков
  if AViewInfo.Node.HasChildren then
    aCanvas.Font.Style := [fsBold];

// Форматирование значения колонки "Изменено" в зависимости от "Актуальной даты"
  if SameText(AViewInfo.Column.Name, 'TreeUpdated') then
  begin
    if AViewInfo.Node.Values[trUpdated] <> Null then
    begin
      if (Trunc(AViewInfo.Node.Values[trUpdated]) > ActualDate.Date) then
      begin
        aCanvas.Font.Color := clRed;
        aDone := False;
        Exit;
      end;
    end;
  end;

// Форматирование значения колонки "Дата кон." в зависимости от "Актуальной даты"
  if SameText(AViewInfo.Column.Name, 'TreeDateExpired') then
  begin
    if AViewInfo.Node.Values[trDateExpired] <> Null then
    begin
      if (AViewInfo.Node.Values[trDateExpired] > ActualDate.Date) then
      begin
        aCanvas.Font.Color := clRed;
        aDone := False;
        Exit;
      end;
    end;
  end;

// Форматирование строки для "удаленных" записей
  if (AViewInfo.Node.Values[trDateExpired] <> Null) then
  begin
    if (AViewInfo.Node.Values[trDateExpired] <= ActualDate.Date) then
    begin
      if TreeList.FocusedNode = AViewInfo.Node then
      begin
        if TreeList.FocusedColumn = aViewInfo.Column
          then aCanvas.Font.Color := clGray
          else aCanvas.Font.Color := clSilver
      end else aCanvas.Font.Color := clGray;
      aDone := False;
      Exit;
    end;
  end;
end;

procedure TForm1.ExecuteSQL(aSQL: string);
var
  TempQuery: TADOQuery;
begin
  TempQuery := TADOQuery.Create(Self);
  TempQuery.Connection := DataModule2.DB;
  try
//    TempQuery.Close;
//    TempQuery.SQL.Clear;
    TempQuery.SQL.Add(aSQL);
    TempQuery.ExecSQL;
  finally
    TempQuery.Free
  end;
end;

function TForm1.OpenSQL(aSQL: string): TADOQuery;
begin
  Result := TADOQuery.Create(Self);
  Result.Connection := DataModule2.DB;

//  Result.Close;
//  Result.SQL.Clear;
  Result.SQL.Add(Format('SELECT * FROM _OBJECTS WHERE GUID_PARENT = ''%s'' AND DATEEXPIRED IS NULL', [GUIDToString(DragGUID)]));
  Result.Open;
end;

procedure TForm1.TreeDragTo(DragGUID, DropGUID: TGUID);
var
  NewGUID: TGUID;
begin
// Рекурсивная процедура "перемещения" записей
// Устанавливаем дату окончания для переносимого объекта
  ExecuteSQL(Format('DELETE FROM _OBJECTS WHERE GUID = ''%s''', [GUIDToString(DragGUID)]));

// Добавляем новый объект к требуемому владельцу
  CreateGUID(NewGUID);
  ExecuteSQL(Format('INSERT INTO _OBJECTS (GUID, GUID_PARENT, LEVEL, NAME) '+
                    '  SELECT ''%s'', ''%s'', LEVEL, NAME FROM _OBJECTS WHERE GUID = ''%s''',
                    [GUIDToString(NewGUID), GUIDToString(DropGUID), GUIDToString(DragGUID)]));

// Добавляем дочерние объекты которые были у переносимого объекта
  with OpenSQL(Format('SELECT * FROM _OBJECTS WHERE GUID_PARENT = ''%s'' AND DATEEXPIRED IS NULL', [GUIDToString(DragGUID)])) do
  while not EOF do
  try
// Рекурсия по всем дочерним объектам
    TreeDragTo((FieldByName('GUID') as TGUIDField).AsGuid, NewGUID);
    Next;
  finally
    Free;
  end;

// Обновление дерева
  TreeListReOpen(TreeList, 'GUID', NewGUID);
end;

procedure TForm1.TreeMoveTo(FromGUID, ToGUID, NewGUID: TGUID);
var
  NewChildGUID: TGUID;
begin
// Рекурсивная процедура "перемещения" записей
// Устанавливаем дату окончания для переносимого объекта
  ExecuteSQL(Format('DELETE FROM _OBJECTS WHERE GUID = ''%s''', [GUIDToString(FromGUID)]));

// Добавляем новый объект к требуемому владельцу
  ExecuteSQL(Format('INSERT INTO _OBJECTS (GUID, GUID_PARENT, LEVEL, NAME) '+
                    '  SELECT ''%s'', ''%s'', LEVEL, NAME FROM _OBJECTS WHERE GUID = ''%s''',
                    [GUIDToString(NewGUID), GUIDToString(ToGUID), GUIDToString(FromGUID)]));

// Добавляем дочерние объекты которые были у переносимого объекта
  with OpenSQL(Format('SELECT * FROM _OBJECTS WHERE GUID_PARENT = ''%s'' AND DATEEXPIRED IS NULL', [GUIDToString(FromGUID)])) do
  while not EOF do
  try
// Рекурсия по всем дочерним объектам
    CreateGUID(NewChildGUID);
    TreeMoveTo((FieldByName('GUID') as TGUIDField).AsGuid, NewGUID, NewChildGUID);
    Next;
  finally
    Free;
  end;

// Обновление дерева
  TreeListReOpen(TreeList, 'GUID', NewGUID);
end;

procedure TForm1.TreeMoveTo(FromGUID, NewGUID: TGUID);
var
  NewChildGUID: TGUID;
begin
// Рекурсивная процедура "перемещения" записей
// Устанавливаем дату окончания для переносимого объекта
  ExecuteSQL(Format('DELETE FROM _OBJECTS WHERE GUID = ''%s''', [GUIDToString(FromGUID)]));

// Добавляем новый объект к требуемому владельцу
  ExecuteSQL(Format('INSERT INTO _OBJECTS (GUID, LEVEL, NAME) '+
                    '  SELECT ''%s'', LEVEL, NAME FROM _OBJECTS WHERE GUID = ''%s''',
                    [GUIDToString(NewGUID), GUIDToString(FromGUID)]));

// Добавляем дочерние объекты которые были у переносимого объекта
  with OpenSQL(Format('SELECT * FROM _OBJECTS WHERE GUID_PARENT = ''%s'' AND DATEEXPIRED IS NULL', [GUIDToString(FromGUID)])) do
  while not EOF do
  try
// Рекурсия по всем дочерним объектам
    CreateGUID(NewChildGUID);
    TreeMoveTo((FieldByName('GUID') as TGUIDField).AsGuid, NewGUID, NewChildGUID);
    Next;
  finally
    Free;
  end;

// Обновление дерева
  TreeListReOpen(TreeList, 'GUID', NewGUID);
end;

procedure TForm1.TreeDelete(DeleteGUID: TGUID);
begin
// Рекурсивная процедура "удаления" записей
// Устанавливаем дату окончания для "удаляемого" объекта
  ExecuteSQL(Format('DELETE FROM _OBJECTS WHERE GUID = ''%s'' AND DATEEXPIRED IS NULL', [GUIDToString(DeleteGUID)]));

// Удаляем дочерние объекты которые были у "удаляемого" объекта
  with OpenSQL(Format('SELECT * FROM _OBJECTS WHERE GUID_PARENT = ''%s'' AND DATEEXPIRED IS NULL', [GUIDToString(DeleteGUID)])) do
  while not EOF do
  try
// Рекурсия по всем дочерним объектам
    TreeDelete((FieldByName('GUID') as TGUIDField).AsGuid);
    Next;
  finally
    Free;
  end;

// Обновление дерева
  TreeListReOpen(TreeList, 'GUID', DeleteGUID);
end;

procedure TForm1.TreeRestore(RestoreGUID: TGUID; RestoreLevel: integer; RestoreName: string);
var
  aNewGUID: TGUID;
begin
// Рекурсивная процедура "восстановления" записей
// Удаляем дату окончания для "восстанавливаемого" объекта
  CreateGUID(aNewGUID);
  ExecuteSQL(Format('INSERT INTO _OBJECTS (GUID, LEVEL, NAME) VALUES (''%s'', ''%s'', ''%s'')',
             [GUIDToString(aNewGUID), IntToStr(RestoreLevel), RestoreName]));

// Восстанавливаем дочерние объекты которые были у "удаленного" объекта
  with OpenSQL(Format('SELECT * FROM _OBJECTS WHERE GUID_PARENT = ''%s'' AND DATEEXPIRED IS NOT NULL', [GUIDToString(RestoreGUID)])) do
  while not EOF do
  try
// Рекурсия по всем дочерним объектам
    TreeRestore(aNewGuid,
                (FieldByName('GUID') as TGUIDField).AsGuid,
                FieldByName('Level').AsInteger,
                FieldByName('Name').AsString);
    Next;
  finally
    Free;
  end;

// Обновление дерева
  TreeListReOpen(TreeList, 'GUID', aNewGUID);
end;

procedure TForm1.TreeRestore(RestoreGUID, RestoreGUID_Parent: TGUID; RestoreLevel: integer; RestoreName: string);
var
  aNewGUID: TGUID;
begin
// Рекурсивная процедура "восстановления" записей
// Удаляем дату окончания для удаляемого объекта
  CreateGUID(aNewGUID);
  ExecuteSQL(Format('INSERT INTO _OBJECTS (GUID, GUID_PARENT, LEVEL, NAME) VALUES (''%s'', ''%s'', ''%s'', ''%s'')',
             [GUIDToString(aNewGUID), GUIDToString(RestoreGUID), IntToStr(RestoreLevel), RestoreName]));

// Восстанавливаем дочерние объекты которые были у удаленного объекта
  with OpenSQL(Format('SELECT * FROM _OBJECTS WHERE GUID_PARENT = ''%s'' AND DATEEXPIRED IS NOT NULL', [GUIDToString(RestoreGUID_Parent)])) do
  while not EOF do
  try
// Рекурсия по всем дочерним объектам
    TreeRestore(aNewGuid,
                (FieldByName('GUID') as TGUIDField).AsGuid,
                FieldByName('LEVEL').AsInteger,
                FieldByName('NAME').AsString);
    Next;
  finally
    Free;
  end;

// Обновление дерева
  TreeListReOpen(TreeList, 'GUID', aNewGUID);
end;

procedure TForm1.AboutActionExecute(Sender: TObject);
begin
// Экшн "О задании"
  ShowAboutForm;
end;

function TForm1.CreateMainQuery: string;
begin
// Формирование главного запроса
  Result :=
    'select o.id, o.guid, o.guid_parent, '+
    '  o.level, l.name as level_name, o.name, o.datestart, '+
    '  o.dateexpired, '+
    '  o.updated '+
    'from _objects o '+
    'left join _levels l on l.id = o.level '+
    'where '''+FormatDateTime('MM.dd.yyyy', ActualDate.Date)+''' >= DATESTART ';

  if not ShowDeletedAction.Checked then
    Result := Result +
      '  and ((dateexpired is null) or ('''+FormatDateTime('MM.dd.yyyy', ActualDate.Date)+''' <= dateexpired)) ';

  Result := Result +
    'order by o.level, o.name';
end;

procedure TForm1.ShowDeletedActionExecute(Sender: TObject);
var
  ID: integer;
begin
// Переключение видимости "удаленных" записей
  ID := 0;
  ShowDeletedAction.Checked := not ShowDeletedAction.Checked;

  if Assigned(TreeList.DataController.DataSet) then
    ID := TreeList.DataController.DataSet.FieldByName('ID').Value;

  DataModule2.Main.Close;
  DataModule2.Main.SQL.Clear;
  DataModule2.Main.SQL.Add(CreateMainQuery);
  DataModule2.Main.Open;

// Обновление дерева
  TreeListReOpen(TreeList, 'ID', ID);

// Смена иконки и надписи к экшну
  if ShowDeletedAction.Checked then
  begin
    ShowDeletedAction.ImageIndex := 6;
    ShowDeletedAction.Caption := 'Скрывать удаленные';
    ShowDeletedAction.Hint := 'Скрывать удаленные записи';
  end else
  begin
    ShowDeletedAction.ImageIndex := 7;
    ShowDeletedAction.Caption := 'Показывать удаленные';
    ShowDeletedAction.Hint := 'Показывать удаленные записи';
  end;
end;

procedure TForm1.ActualDateActionUpdate(Sender: TObject);
var
  ID: integer;
begin
// Экшн "Смена актуальной даты"
  if ActualDate.Date = PrevActualDate then Exit;
  PrevActualDate := ActualDate.Date;

  ID := 0;
  if Assigned(TreeList.DataController.DataSet) then
    ID := IIF(VarIsNull(TreeList.DataController.DataSet.FieldByName('ID').Value), 0, TreeList.DataController.DataSet.FieldByName('ID').Value);

  DataModule2.Main.Close;
  DataModule2.Main.SQL.Clear;
  DataModule2.Main.SQL.Add(CreateMainQuery);
  DataModule2.Main.Open;

// Обновление дерева
  TreeListReOpen(TreeList, 'ID', ID);
end;

function TForm1.CheckActualDate: boolean;
begin
  Result := ActualDate.Date >= Trunc(Now);
  if not Result then
    MessageDlg('Актуальная дата меньше текущей.'+#13#10+'Изменения запрещены!', mtError, [mbCancel], 0);
end;

procedure TForm1.AddActionExecute(Sender: TObject);
var
  aGUID: TGUID;
  aLevel: integer;
  aNewName: string;
begin
// Экшн "Добавление объекта в текущий уровень"

// Нельзя изменять, если актуальная дата меньше текущей
  if not CheckActualDate then Exit;

// Нельзя добавлять к "удаленным" объектам
  if (TreeList.FocusedNode.Values[trDateExpired] <> Null) then
  begin
    MessageDlg('Нельзя добавлять к удаленным объектам!', mtError, [mbCancel], 0);
    Exit;
  end;

  CreateGUID(aGUID);
  aLevel := StrToInt(TreeList.FocusedNode.Values[trLevel]);

  aNewName := InputBox(LevelNames.Strings[aLevel-1], 'Введите новое значенние: ', '');
  if aNewName > '' then
  begin
    ExecuteSQL(Format('INSERT INTO _OBJECTS (GUID, LEVEL, NAME) VALUES (''%s'', ''%s'', ''%s'')',
               [GUIDToString(aGUID), IntToStr(aLevel), aNewName]));

// Обновление дерева
    TreeListReOpen(TreeList, 'GUID', aGUID);
  end;
end;

procedure TForm1.AddChildActionExecute(Sender: TObject);
var
  aGUID: TGUID;
  aLevel: integer;
  aNewName: string;
begin
// Экшн "Добавление дочернего объекта к текущей записи"

// Нельзя изменять, если актуальная дата меньше текущей
  if not CheckActualDate then Exit;

// Нельзя добавлять потомков к "удаленным" объектам
  if (TreeList.FocusedNode.Values[trDateExpired] <> Null) then
  begin
    MessageDlg('Нельзя добавлять потомков к удаленным объектам!', mtError, [mbCancel], 0);
    Exit;
  end;

  aLevel := StrToInt(TreeList.FocusedNode.Values[trLevel]);

// Нельзя добавлять потомков к уровню "Сотрудник"
  if (aLevel = 6) then
  begin
    MessageDlg('Нельзя добавлять потомков к уровню "Сотрудник"!', mtError, [mbCancel], 0);
    Exit;
  end;

  CreateGUID(aGUID);
  aNewName := InputBox(LevelNames.Strings[aLevel], 'Введите новое значенние: ', '');
  if aNewName > '' then
  begin
    ExecuteSQL(Format('INSERT INTO _OBJECTS (GUID, GUID_PARENT, LEVEL, NAME) VALUES (''%s'', ''%s'', ''%s'', ''%s'')',
               [GUIDToString(aGUID), TreeList.FocusedNode.Values[trGUID], IntToStr(aLevel+1), aNewName]));

// Обновление дерева
    TreeListReOpen(TreeList, 'GUID', aGUID);
  end;
end;

procedure TForm1.DeleteActionExecute(Sender: TObject);
begin
// Экшн "Удаление записи"

// Нельзя изменять, если актуальная дата меньше текущей
  if not CheckActualDate then Exit;

  if MessageDlg('Удалить записи?', mtConfirmation, [mbYes, mbNo], 0) = mrNo then Exit;

// Проверка на признак удаление записи
  if TreeList.FocusedNode.Values[trDateExpired] <> NULL
    then MessageDlg('Нельзя удалить уже удаленный объект!', mtInformation, [mbCancel], 0)
// Запуск рекурсивной процедуры "удаления" записей
    else TreeDelete(StringToGUID(TreeList.FocusedNode.Values[trGUID]));
end;

procedure TForm1.RestoreActionExecute(Sender: TObject);
begin
// Экшн "Восстановление записи"

// Нельзя изменять, если актуальная дата меньше текущей
  if not CheckActualDate then Exit;

  if MessageDlg('Восстановить записи?', mtConfirmation, [mbYes, mbNo], 0) = mrNo then Exit;

// Проверка на признак удаление записи
  if TreeList.FocusedNode.Values[trDateExpired] = NULL
    then MessageDlg('Нельзя восстановить не удаленный объект!', mtInformation, [mbCancel], 0)
// Запуск рекурсивной процедуры "восстановления" записей
    else
    begin
      if TreeList.FocusedNode.Values[trGUID_Parent] = Null then
        TreeRestore(StringToGUID(TreeList.FocusedNode.Values[trGUID]),
                    TreeList.FocusedNode.Values[trLevel],
                    TreeList.FocusedNode.Values[trName])
      else
        TreeRestore(StringToGUID(TreeList.FocusedNode.Values[trGUID]),
                    StringToGUID(TreeList.FocusedNode.Values[trGUID_Parent]),
                    TreeList.FocusedNode.Values[trLevel],
                    TreeList.FocusedNode.Values[trName]);
    end;
end;

procedure TForm1.EditActionExecute(Sender: TObject);
var
  aGUID, aNewGUID: TGUID;
  aLevel: integer;
  aName, aNewName: string;
begin
// Экшн "Редактирование"

  TreeList.BeginUpdate;
  try
  // Нельзя изменять, если актуальная дата меньше текущей
    if not CheckActualDate then Exit;

  // Нельзя изменять "удаленные" объекты
    if (TreeList.FocusedNode.Values[trDateExpired] <> Null) then
    begin
      MessageDlg('Нельзя изменять удаленные объекты!', mtError, [mbCancel], 0);
      Exit;
    end;

    aGUID := StringToGUID(TreeList.FocusedNode.Values[trGUID]);
    aLevel := StrToInt(TreeList.FocusedNode.Values[trLevel]);
    aName := TreeList.FocusedNode.Values[trName];
    if TreeList.FocusedNode.Values[trDateExpired] <> NULL then Exit;

    aNewName := InputBox(LevelNames.Strings[aLevel-1], 'Введите новое значенние: ', aName);
    if aName <> aNewName then
    begin
      CreateGUID(aNewGUID);
      if TreeList.FocusedNode.Values[trGUID_Parent] <> Null then
        TreeMoveTo(aGUID, StringToGUID(TreeList.FocusedNode.Values[trGUID_Parent]), aNewGUID)
      else TreeMoveTo(aGUID, aNewGUID);

      ExecuteSQL(Format('UPDATE _OBJECTS SET NAME = ''%s'' WHERE GUID = ''%s'' AND DATEEXPIRED IS NULL',
                 [aNewName, GUIDToString(aNewGUID)]));

      TreeListReOpen(TreeList, 'GUID', aGUID);
    end;
  finally
    TreeList.EndUpdate;
  end;
end;

function TForm1.DataBaseExists(DBName: string): boolean;
var
  TempQuery: TADOQuery;
begin
// Проверка наличия базы данных
  TempQuery := TADOQuery.Create(Self);
  try
    TempQuery.Close;
    TempQuery.SQL.Clear;
    TempQuery.SQL.Add(Format('select name from sys.databases where upper(name) = ''%s''', [UpperCase(DBName)]));
    TempQuery.ConnectionString := 'Provider=SQLOLEDB.1;Integrated Security=SSPI;Persist Security Info=False;Initial Catalog=master';
    TempQuery.Open;
    Result := not TempQuery.EOF;
    TempQuery.Close;
  finally
    TempQuery.Free;
  end;
end;

procedure TForm1.CheckDataBase;
begin
// Установка видимости начального меню
  if DataBaseExists('dovidka') then
  begin
    CreateBaseItem.Visible := False;
    ConnectBaseItem.Visible := True;
    DeleteBaseItem.Visible := True;
  end else
  begin
    CreateBaseItem.Visible := True;
    ConnectBaseItem.Visible := False;
    DeleteBaseItem.Visible := False;
  end;
end;

procedure TForm1.ExecuteScriptFromFile(aFileName: string);
var
  aScriptList: TStrings;
  aScript, aScriptName: string;
begin
// Считать и выполнить скрипт из файла
  if not FileExists(aFileName) then aFileName := '..\..\'+aFileName;

  aScriptList := TStringlist.Create;
  try
    aScriptList.LoadFromFile(aFileNAme);
  finally
    aScript := aScriptList.Text;
    aScriptList.Free;
  end;

  DataModule2.DB.Execute(aScript);
end;

procedure TForm1.CreateBaseActionExecute(Sender: TObject);
begin
// Экшн "Создание базы данных
  DataModule2.DB.Connected := False;
  DataModule2.DB.ConnectionString := 'Provider=SQLOLEDB.1;Integrated Security=SSPI;Persist Security Info=False;Initial Catalog=master';

  try
    DataModule2.DB.Execute('USE MASTER');
    DataModule2.DB.Execute('CREATE DATABASE DOVIDKA');

  // Создание и наполнение таблиц находится в файле Tables.sql
    ExecuteScriptFromFile('Tables.sql');

    DataModule2.DB.Execute('SET ANSI_NULLS ON');
    DataModule2.DB.Execute('SET QUOTED_IDENTIFIER ON');

  // Функции и триггеры создаются отдельно (в одной команде - один)
{
    DataModule2.DB.Execute
    (
      'CREATE TRIGGER [DBO].[InsertObjects] ON [DBO].[_Objects] After Insert '+
      'AS '+
      'BEGIN '+
      '  SET NOCOUNT ON; '+
      '  UPDATE DBO._OBJECTS SET UPDATED = CURRENT_TIMESTAMP '+
      '    WHERE GUID IN (SELECT GUID FROM INSERTED); '+
      'END '
    );
}
    DataModule2.DB.Execute
    (
      'CREATE TRIGGER [DBO].[UpdateObjects] ON [DBO].[_Objects] INSTEAD OF Update '+
      'AS '+
//      'DECLARE @myid uniqueidentifier = NEWID(); '+
      'BEGIN '+
      '  SET NOCOUNT ON; '+
{
      '  UPDATE DBO._OBJECTS SET DATEEXPIRED = GETDATE(), UPDATED = CURRENT_TIMESTAMP '+
      '    WHERE GUID IN (SELECT GUID FROM INSERTED WHERE DATEEXPIRED IS NULL); '+
      '  INSERT INTO DBO._OBJECTS (GUID, GUID_PARENT, LEVEL, NAME, DATESTART, DATEEXPIRED) '+
      '   	SELECT @myid, GUID_PARENT, LEVEL, NAME, GETDATE(), NULL FROM INSERTED WHERE DATEEXPIRED IS NULL; '+
      '  UPDATE DBO._OBJECTS SET GUID_PARENT = @myid, UPDATED = CURRENT_TIMESTAMP '+
      '	   WHERE GUID_PARENT IN (SELECT GUID FROM INSERTED WHERE DATEEXPIRED IS NULL); '+
      '  UPDATE DBO._OBJECTS SET NAME = UPDATED = CURRENT_TIMESTAMP '+
      '    WHERE GUID IN (SELECT GUID FROM INSERTED WHERE DATEEXPIRED IS NULL); '+
}
      '  DECLARE @ID INT; '+
      '  DECLARE @NAME VARCHAR(255); '+
    	'  DECLARE _INSERTED CURSOR FOR '+
      '    SELECT ID, NAME FROM INSERTED; '+
      '  OPEN _INSERTED; '+
      '  FETCH NEXT FROM _INSERTED INTO @ID, @NAME; '+
      '  WHILE (@@FETCH_STATUS <> -1) '+
      '  BEGIN ' +
      '    UPDATE [DBO].[_Objects] '+
      '      SET NAME = @NAME, UPDATED = CURRENT_TIMESTAMP '+
      '    WHERE ID = @ID '+
      '    FETCH NEXT FROM _INSERTED INTO @ID, @NAME; '+
      '  END '+
      '	 CLOSE _INSERTED; '+
      '  DEALLOCATE _INSERTED; '+
      'END '
    );

    DataModule2.DB.Execute
    (
      'CREATE TRIGGER [dbo].[DeleteObjects] ON [dbo].[_objects] INSTEAD OF Delete '+
      'AS '+
      'BEGIN '+
      '  SET NOCOUNT ON; '+
      '  DECLARE @ID INT; '+
      '  DECLARE @DATEEXPIRED DATE; '+
    	'  DECLARE _DELETED CURSOR FOR '+
      '    SELECT ID, DATEEXPIRED FROM DELETED; '+
      '  OPEN _DELETED; '+
      '  FETCH NEXT FROM _DELETED INTO @ID, @DATEEXPIRED; '+
      '  WHILE (@@FETCH_STATUS <> -1) '+
      '  BEGIN ' +
      '    UPDATE [DBO].[_Objects] '+
      '      SET DATEEXPIRED = CASE WHEN @DATEEXPIRED IS NULL THEN GETDATE() ELSE NULL END, UPDATED = CURRENT_TIMESTAMP '+
      '    WHERE ID = @ID '+
      '    FETCH NEXT FROM _DELETED INTO @ID, @DATEEXPIRED; '+
      '  END '+
      '	 CLOSE _DELETED; '+
      '  DEALLOCATE _DELETED; '+
      'END '
    );

    DataModule2.DB.Execute
    (
      'Create Function [DBO].[Z](@data date) '+
      'Returns Date '+
      'as '+
      'begin '+
      '  declare @Ret date '+
      '  set @Ret = @Data '+
      '  if @Ret is NULL '+
      '    Set @Ret = ''01/01/2200 '''+
      '  Return(@Ret) '+
      'end '
    );
  except
    on E: EAdoError do
    begin
      // ADO specific error handling
      MessageDlg('ADO Error: '+E.Message, mtError, [mbCancel], 0);
      Exit;
    end;
    on E: EDatabaseError do
    begin
      // Generic database error handling
      MessageDlg('Database Error: '+E.Message, mtError, [mbCancel], 0);
      Exit;
    end;
    on E: Exception do
    begin
      // Other exceptions (non-DB related)
      MessageDlg('Exception: '+E.Message, mtError, [mbCancel], 0);
      Exit;
    end;
  end;

  MessageDlg('База данных "dovidka" создана успешно!', mtInformation, [mbOk], 0);

// Проверка базы данных и смена менюшек
  CheckDataBase;
end;

procedure TForm1.ConnectBaseActionExecute(Sender: TObject);
var
  i, Num: integer;
  IniFile: TIniFile;
  Sections: TStrings;
begin
// Экшн "Подключение к базе данных"
  DataModule2.DB.Connected := False;
  DataModule2.DB.ConnectionString := 'Provider=SQLOLEDB.1;Integrated Security=SSPI;Persist Security Info=False;User ID=sa;Initial Catalog=dovidka;';

  try
    DataModule2.DB.Connected := True;
  except
    on E: EAdoError do
    begin
      // ADO specific error handling
      MessageDlg('ADO Error: '+E.Message, mtError, [mbCancel], 0);
      Exit;
    end;
    on E: EDatabaseError do
    begin
      // Generic database error handling
      MessageDlg('Database Error: '+E.Message, mtError, [mbCancel], 0);
      Exit;
    end;
    on E: Exception do
    begin
      // Other exceptions (non-DB related)
      MessageDlg('Exception: '+E.Message, mtError, [mbCancel], 0);
      Exit;
    end;
  end;

// Смена менюшек
  TreeList.Visible := True;
  BarManBar1.Visible := True;

  CreateBaseItem.Visible := False;
  ConnectBaseItem.Visible := False;
  DeleteBaseItem.Visible := False;

  AboutMenuItem.Visible := True;
  EditMenuItem.Visible := True;
  ReOpenMenuItem.Visible := True;
  AddMenuItem.Visible := True;
  AddChildMenuItem.Visible := True;
  DeleteMenuItem.Visible := True;
  RestoreMenuItem.Visible := True;
  ShowDeletedMenuItem.Visible := True;

// RunTime меню для dependency injection
  Sections := TStringList.Create;
  try
    IniFile := ConnectToIniFile('Menus.Ini');
    try
      IniFile.ReadSections(Sections);
    finally
      IniFile.Free;
    end;

    for I := 0 to Pred(Sections.Count) do
    begin
      MainMenu.Items.Add(CreateMenuItem(Sections[i]));
      TreePopup.Items.Add(CreateMenuItem(Sections[i]));
    end;
  finally
    Sections.Free;
  end;

// Заполнение списка наименования уровней
  with OpenSQL('SELECT ID, NAME FROM _LEVELS') do
  while not EOF do
  try
    LevelNames.Add(FieldByName('NAME').Value);
    Next;
  finally
    Free;
  end;

// Открытие главного запроса
  DataModule2.Main.Open;
end;

procedure TForm1.DeleteBaseActionExecute(Sender: TObject);
begin
// Экшн "Удаление базы данных"
  DataModule2.DB.Connected := False;
  DataModule2.DB.ConnectionString := 'Provider=SQLOLEDB.1;Integrated Security=SSPI;Persist Security Info=False;User ID=sa;Initial Catalog=master;';
  DataModule2.DB.Connected := True;

  try
    DataModule2.DB.Execute('use master');
    DataModule2.DB.Execute('alter database [dovidka] set single_user with rollback immediate');
    DataModule2.DB.Execute('drop database dovidka');
  except
    on E: EAdoError do
    begin
      // ADO specific error handling
      MessageDlg('ADO Error: '+E.Message, mtError, [mbCancel], 0);
      Exit;
    end;
    on E: EDatabaseError do
    begin
      // Generic database error handling
      MessageDlg('Database Error: '+E.Message, mtError, [mbCancel], 0);
      Exit;
    end;
    on E: Exception do
    begin
      // Other exceptions (non-DB related)
      MessageDlg('Exception: '+E.Message, mtError, [mbCancel], 0);
      Exit;
    end;
  end;
  DataModule2.DB.Connected := False;
  MessageDlg('База данных "dovidka" удалена успешно!', mtInformation, [mbOk], 0);

// Проверка базы данных и смена менюшек
  CheckDataBase;
end;

procedure TForm1.FormCreate(Sender: TObject);
begin
// наименовния уровней
  LevelNames := TStringList.Create;

// Смена менюшек
  TreeList.Visible := False;
  BarManBar1.Visible := False;

  AboutMenuItem.Visible := False;
  EditMenuItem.Visible := False;
  ReOpenMenuItem.Visible := False;
  AddMenuItem.Visible := False;
  AddChildMenuItem.Visible := False;
  DeleteMenuItem.Visible := False;
  RestoreMenuItem.Visible := False;
  ShowDeletedMenuItem.Visible := False;

// Проверка базы данных и смена менюшек
  CheckDataBase;
end;

procedure TForm1.FormDestroy(Sender: TObject);
begin
// Освобождение памяти от списка наименований уровней
  LevelNames.Free;
end;

procedure TForm1.ReOpenActionExecute(Sender: TObject);
begin
// Перречитать все дерево и установить курсор на текущую позицию
  TreeListReOpen(TreeList);
end;

procedure TForm1.TreeListDragDrop(Sender, Source: TObject; X, Y: Integer);
var
  Node: TcxTreeListNode;
begin
  Node := TreeList.GetNodeAt(X, Y);
// Вставить перетаскиваемый объект со всеми потомками в требуемую позицию
// Бывший перетаскиваемый объект при этом помечается как "удаленный"
  TreeDragTo(StringToGUID(DragNode.Values[trGUID]), StringToGUID(Node.Values[trGUID]));
end;

procedure TForm1.TreeListDragOver(Sender, Source: TObject; X, Y: Integer;
  State: TDragState; var Accept: Boolean);
var
  Node: TcxTreeListNode;
begin
  Node := TreeList.GetNodeAt(X, Y);
// Перетаскивать можно только когда актуальная дата >= текущей, только на уровень выше
// Для уровней ниже "Предприятие" нельзя претасиквать на "Местоположение"
// "Удаленные" и на "удаленные" объекты перетасивать нельзя
  Accept := (ActualDate.Date >= Trunc(Now)) and
            (Node.Values[trLevel] < DragNode.Values[trLevel]) and
            ((DragNode.Values[trLevel] = 2) or ((DragNode.Values[trLevel] > 2) and (Node.Values[trLevel] > 1))) and
//            (IIF(VarIsNull(Node.Values[trDateExpired]), '', '01.01.2900') = '');
            (Node.Values[trDateExpired] = Null);

end;

procedure TForm1.TreeListMouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  // Нажата левая кнопка мыши - перетаскивание
  if Button = mbLeft then
  begin
    DragNode := TreeList.GetNodeAt(X, Y);
  // Перетаскивать можно только когда актуальная дата >= текущей
  // Удаленные объекты перетасивать нельзя
//    if IIF(VarIsNull(DragNode.Values[trDateExpired]), '', '01.01.2900') = ''
    if (DragNode.Values[trDateExpired] = Null) and (ActualDate.Date >= Trunc(Now))
      then TreeList.BeginDrag(False, 10);
  end;
  // Нажата правая кнопка мыши - контекстное меню
  if Button = mbRight then TreePopup.Popup(Mouse.CursorPos.X, Mouse.CursorPos.Y);
end;

end.
